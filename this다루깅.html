<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <input type="button" id="id_diff" value="눌러방방"/>
  <script>
    var v_btn = document.querySelector('#id_diff');

    var f_click = function (p_name, p_insa) {
      console.log(this);
      console.log(this.name);
      alert(p_name + "님" + p_insa);
    }
    
    var v_obj337 = {
      name : "어진임금님"
    }
    // bind는 함수를 바로 call하지 않고, 새로운 함수를 내부적으로 맹글어서
    // 그 함수 포인터(FP)를 리턴해줌
    v_btn.addEventListener('click', f_click.bind(v_obj337, "어진", "훌륭하십니다."));

    function f_this(p_arg1, p_arg2) {
      console.log(this, p_arg1, p_arg2);
    }
    // this가 가리키는 값이 상황에 따라 바뀐다는 불만에
    // 직접 this를 세팅할 수 있는  3개의 method를 제공함
    // call, apply, bind - bind가 특히 중요

    var v_obj = {
      name : "정현아짱"
    }
    v_obj.huk = f_this;

    v_obj.huk.call(window, "첫번째", "두번째"); // window는 매개변수로 넘어가지 않는다.
    v_obj.huk.call(document, "first", "seccond"); //? 

    // apply는 call과 똑같으나, 매개변수를 항상 배열에 담아서 보내야 함
    var v_arr2 = ["첫번째", "두번째"];
    v_obj.huk.apply(window, v_arr2); // window는 매개변수로 넘어가지 않는다.
    v_obj.huk.apply(document, ["first", "seccond"]); //? 


  </script>
</body>
</html>